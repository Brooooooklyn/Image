/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface AvifConfig {
  /** 0-100 scale */
  quality?: number | undefined | null
  /** 0-100 scale */
  alphaQuality?: number | undefined | null
  /** rav1e preset 1 (slow) 10 (fast but crappy) */
  speed?: number | undefined | null
  /** True if RGBA input has already been premultiplied. It inserts appropriate metadata. */
  premultipliedAlpha?: boolean | undefined | null
  /** Which pixel format to use in AVIF file. RGB tends to give larger files. */
  colorSpace?: ColorSpace | undefined | null
  /** How many threads should be used (0 = match core count) */
  threads?: number | undefined | null
}
export const enum ColorSpace {
  YCbCr = 0,
  RGB = 1,
}
export function encodeAvif(input: Buffer, config?: AvifConfig | undefined | null): Buffer
export interface JpegCompressOptions {
  /** Output quality, default is 100 (lossless) */
  quality?: number | undefined | null
  /**
   * If true, it will use MozJPEGâ€™s scan optimization. Makes progressive image files smaller.
   * Default is `true`
   */
  optimizeScans?: boolean | undefined | null
}
/**
 * # Safety
 *
 * The output buffer from `mozjpeg` is checked by V8 while converting it into Node.js Buffer.
 */
export function compressJpeg(input: Buffer, options?: JpegCompressOptions | undefined | null): Buffer
export interface PNGLosslessOptions {
  /**
   * Attempt to fix errors when decoding the input file rather than returning an Err.
   * Default: `false`
   */
  fixErrors?: boolean | undefined | null
  /**
   * Write to output even if there was no improvement in compression.
   * Default: `false`
   */
  force?: boolean | undefined | null
  /** Which filters to try on the file (0-5) */
  filter?: Array<number> | undefined | null
  /**
   * Whether to attempt bit depth reduction
   * Default: `true`
   */
  bitDepthReduction?: boolean | undefined | null
  /**
   * Whether to attempt color type reduction
   * Default: `true`
   */
  colorTypeReduction?: boolean | undefined | null
  /**
   * Whether to attempt palette reduction
   * Default: `true`
   */
  paletteReduction?: boolean | undefined | null
  /**
   * Whether to attempt grayscale reduction
   * Default: `true`
   */
  grayscaleReduction?: boolean | undefined | null
  /**
   * Whether to perform IDAT recoding
   * If any type of reduction is performed, IDAT recoding will be performed regardless of this setting
   * Default: `true`
   */
  idatRecoding?: boolean | undefined | null
  /** Whether to remove ***All non-critical headers*** on PNG */
  strip?: boolean | undefined | null
  /** Whether to use heuristics to pick the best filter and compression */
  useHeuristics?: boolean | undefined | null
}
export function losslessCompressPng(input: Buffer, options?: PNGLosslessOptions | undefined | null): Buffer
export interface PngQuantOptions {
  /** default is 70 */
  minQuality?: number | undefined | null
  /** default is 99 */
  maxQuality?: number | undefined | null
  /**
   * 1- 10
   * Faster speeds generate images of lower quality, but may be useful for real-time generation of images.
   * default: 5
   */
  speed?: number | undefined | null
  /**
   * Number of least significant bits to ignore.
   * Useful for generating palettes for VGA, 15-bit textures, or other retro platforms.
   */
  posterization?: number | undefined | null
}
export function pngQuantize(input: Buffer, options?: PngQuantOptions | undefined | null): Buffer
/**
 * # Safety
 *
 * The output buffer is checked by V8 while converting it into Node.js Buffer.
 */
export function losslessEncodeWebp(input: Buffer): Buffer
/**
 * The quality factor `quality_factor` ranges from 0 to 100 and controls the loss and quality during compression.
 * The value 0 corresponds to low quality and small output sizes, whereas 100 is the highest quality and largest output size.
 * https://developers.google.com/speed/webp/docs/api#simple_encoding_api
 */
export function encodeWebp(input: Buffer, qualityFactor: number): Buffer
